package org.jooq.mcve.test.java.mysql;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.Executors;
import org.jooq.Configuration;
import org.jooq.SQLDialect;
import org.jooq.impl.DefaultConfiguration;
import org.jooq.tools.JooqLogger;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import static org.jooq.mcve.java.mysql.Tables.*;
import static org.junit.Assert.*;


public class TestUsingConnectionPool {

  static JooqLogger log = JooqLogger.getLogger(TestUsingConnectionPool.class);
  static HikariDataSource  dataSource;
  static Configuration configuration;

  @BeforeClass
  public static void init() {

    // Configure HikariCP
    HikariConfig config = new HikariConfig();
    config.setJdbcUrl(System.getProperty("jooq.codegen.jdbc.url"));
    config.setUsername(System.getProperty("jooq.codegen.jdbc.username"));
    config.setPassword(System.getProperty("jooq.codegen.jdbc.password"));

    // Pool configuration
    config.setMaximumPoolSize(5);
    config.setMinimumIdle(5);
    config.setConnectionTimeout(5000);
    config.setIdleTimeout(600000);
    config.setMaxLifetime(1800000);

    // Create the datasource
    dataSource = new HikariDataSource(config);

    configuration = new DefaultConfiguration()
        .set(dataSource)
        .set(SQLDialect.MYSQL)
        .set(Executors.newFixedThreadPool(5));

    log.info("Finished setup with HikariCP");
  }

  @Before
  public void before() {
    configuration.dsl().deleteFrom(TEST).execute();
  }

  @Test
  public void testWhenTxCallbaleReturnTypeIsFuture() {
    CompletionStage<Integer> count =  configuration.dsl().transactionResult(tx -> {
      // add a row to the table asynchronously
      return tx.dsl().insertInto(TEST)
          .columns(TEST.CD)
          .values(42)
          .executeAsync().thenCompose(insertedRows -> {
            // artificial delay
            try {
              Thread.sleep(100);
            } catch (InterruptedException e) {
              throw new RuntimeException(e);
            }
            // get the count of rows in the table asynchronously
            return tx.dsl().selectCount().from(TEST).executeAsync();
          });
    });
    // Wait for the future to complete and assert the count
    // this will throw an exception as after commit connection is returned to the pool
    assertEquals(1, count.toCompletableFuture().join().intValue());
  }

  }